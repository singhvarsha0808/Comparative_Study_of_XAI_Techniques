#Import libraries
import pandas as pd
import numpy as np 
from sklearn.metrics import classification_report
from sklearn.ensemble import GradientBoostingClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.metrics import accuracy_score,confusion_matrix,f1_score,roc_curve, roc_auc_score, auc
from datetime import datetime
import re
import plotly.figure_factory as ff
import pickle
import plotly.express as px
from plotly.offline import init_notebook_mode, iplot, plot
import plotly as py
init_notebook_mode(connected = True)
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from plotly import tools


#function to return summary of dataframe
def df_summary(df):
    # Create an empty dataframe to store the summary
    summary = pd.DataFrame(columns=["Variable", "Type", "Missing Values", "Unique Values", "Distinct Unique Values"])
    
    # Iterate through the columns of the DataFrame
    for col in df.columns:
        # Get the variable type
        var_type = df[col].dtype
        
        # Get the number of missing values
        missing_values = df[col].isna().sum()
        
        # Get the number of unique values
        unique_values = df[col].nunique()
        
        # Get the distinct unique values
        distinct_unique_values = df[col].drop_duplicates().tolist()
        
        # Append the summary information to the summary dataframe
        summary = summary.append({"Variable": col, "Type": var_type, "Missing Values": missing_values, 
                                  "Unique Values": unique_values, "Distinct Unique Values": distinct_unique_values}, ignore_index=True)
    
    return summary

#Function to plot PDP vs ALE graph using values generated by model_profile function of Explainer object
#https://dalex.drwhy.ai/python/api/#dalex.Explainer
def pdp_vs_ale_plot_continous(exp, feature,ale_name,pdp_name,title_text,xaxis_title, y_test ):
    """
    exp: Dalex explainer for the model
    feature: Continous feature for which plot needs to generated. e.g. age  
    ale_name: ALE plot name to be used in legend. e.g. ALE_age
    pdp_name: PDP plot name to be used in legend. e.g. PDP_age
    title_text: Title for the plot. e.g. ALE vs PDP - age
    xaxis_title: Feature name for which plot is created. e.g age 
    y_test: y_test dataframe with prediction scores. It is used to calculate mean line. 
    """
    
    #store ale values
    ale=exp.model_profile(variables = [feature],type = 'accumulated',verbose=False,center=False).result
    #store pdp values
    pdp=exp.model_profile(variables = [feature],type = 'partial',verbose=False).result
    
    #generate ALE vs PDP plot
    fig = make_subplots(shared_xaxes=True)

    fig.add_trace(go.Scatter(x=ale._x_, y=ale._yhat_,
                    mode='lines+markers',
                    name=ale_name,
                    line=dict(color='#008B8B', width=3)))
    
    fig.add_trace(go.Scatter(x=pdp._x_, y=pdp._yhat_,
                    mode='lines',
                    name=pdp_name,
                    line=dict(color='firebrick', width=3)))
    
    fig.add_hline(y_test['y_pred_prob'].mean(), 
                  line_dash="dash", line_color="black",line_width=2,
                  annotation_text="mean prediction", 
                  annotation_position="bottom right")
    
    fig.update_layout(title_text=title_text,
                      xaxis_title=xaxis_title,
                      yaxis_title="Prediction", )

    fig.update_layout(template='plotly_white')
    return fig
    

# fit a model
def fit_model(model,name,filename,X_train,y_train):
    #model = function
    print('\033[1m'+ '\033[4m' + name +'\033[0m')
    start_time = datetime.now()
    print("Start Time: {}" .format(start_time))
    model.fit(X_train,y_train)
    end_time = datetime.now() 
    print("End Time: {}" .format(end_time))
    print('Total time taken:' + '\033[1m' + str(end_time - start_time) + '\033[0m')
    pickle.dump(model, open(filename, 'wb'))

#function to predict and create confusion matrix    
def c_matrix(filename, title,y_test,X_test):
    model = pickle.load(open(filename, 'rb'))
    y_test['predicted']= model.predict(X_test)

    #create confusion matrix 
    model_cm = confusion_matrix(y_test['stroke'], y_test['predicted'])
    model_cm = model_cm[::-1]
    x =  ['Predicted No Stroke', 'Predicted Stroke']
    y =  ['Stroke', 'No Stroke']
    # set up figure 
    fig = ff.create_annotated_heatmap(model_cm, x=x, y=y, colorscale='darkmint')

    # add title
    fig.update_layout(title_text=title, height=400, width=600)

    # adjust margins to make room for yaxis title
    fig.update_layout(margin=dict(t=50, l=200))

    # add colorbar
    fig['data'][0]['showscale'] = True
  
    return fig

#function to create feature importance plot     
def feature_importance(filename,title,df,train_cols):
    model = pickle.load(open(filename, 'rb'))
    f_imp = pd.Series(model.feature_importances_, index=df[train_cols].columns)
    f_imp=f_imp.nlargest(20).to_frame(name ='importance')
    f_imp.reset_index(inplace=True)
    f_imp=f_imp.sort_values('importance',ascending=True)
    fig = px.bar(x=f_imp['importance'], y=f_imp['index'],text_auto=True)
 
    fig.update_layout(title_text=title,
                  xaxis_title="Importance",yaxis_title="Features")

    fig.update_layout(template='plotly_white')

    fig.update_traces(marker_color='rgb(0, 139, 139)', marker_line_color='rgb(125, 196, 196)',
                  marker_line_width=1.5, opacity=1)
    return fig
    

#function to plot roc-auc curve
def plot_auc(filename,y_test,X_test):
    model = pickle.load(open(filename, 'rb'))   
    y_test['y_pred_prob'] = model.predict_proba(X_test)[:, 1]
    
    fpr, tpr, _ = roc_curve(y_test['stroke'], y_test['y_pred_prob'])

    fig = px.area(
        x=fpr, y=tpr,
        title=f'ROC Curve (AUC={auc(fpr, tpr):.4f})',
        labels=dict(x='False Positive Rate', y='True Positive Rate'),
        width=400, height=400, 
        color_discrete_sequence=["#008B8B"], 
    )
    fig.add_shape(
        type='line', line=dict(dash='dash'),
        x0=0, x1=1, y0=0, y1=1
    )
    fig.update_layout(template='plotly_white')
    fig.update_xaxes(constrain='domain')
  
    return fig
